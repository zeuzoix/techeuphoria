# This file is automatically generated by ruby-ll. Manually changing this file
# is not recommended as any changes will be lost the next time this parser is
# re-generated.
require 'll/setup'

module Oga
module XML
##
# DOM parser for both XML and HTML.
#
# This parser does not produce a dedicated AST, instead it emits XML nodes
# directly. Basic usage of this parser is as following:
#
#     parser   = Oga::XML::Parser.new('<foo></foo>')
#     document = parser.parse
#
# To enable HTML parsing you'd use the following instead:
#
#     parser   = Oga::XML::Parser.new('<foo></foo>', :html => true)
#     document = parser.parse
#
# In both cases you can use either a String or an IO as the parser input. IO
# instances will result in lower memory overhead, especially when parsing large
# files.
#
class Parser < LL::Driver
  CONFIG = LL::DriverConfig.new

  CONFIG.terminals = [
    :$EOF, # 0
    :T_TEXT, # 1
    :T_STRING_SQUOTE, # 2
    :T_STRING_DQUOTE, # 3
    :T_STRING_BODY, # 4
    :T_DOCTYPE_START, # 5
    :T_DOCTYPE_END, # 6
    :T_DOCTYPE_TYPE, # 7
    :T_DOCTYPE_NAME, # 8
    :T_DOCTYPE_INLINE, # 9
    :T_COMMENT_START, # 10
    :T_COMMENT_BODY, # 11
    :T_COMMENT_END, # 12
    :T_CDATA_START, # 13
    :T_CDATA_BODY, # 14
    :T_CDATA_END, # 15
    :T_ELEM_START, # 16
    :T_ELEM_NAME, # 17
    :T_ELEM_NS, # 18
    :T_ELEM_END, # 19
    :T_ATTR, # 20
    :T_ATTR_NS, # 21
    :T_XML_DECL_START, # 22
    :T_XML_DECL_END, # 23
    :T_PROC_INS_START, # 24
    :T_PROC_INS_NAME, # 25
    :T_PROC_INS_BODY, # 26
    :T_PROC_INS_END, # 27
  ].freeze

  CONFIG.rules = [
    [3, 0, 0, 1], # 0
    [3, 1, 4, 23, 6, 0], # 1
    [3, 2, 0, 3], # 2
    [3, 3, 0, 7], # 3
    [3, 4, 0, 9], # 4
    [3, 5, 0, 11], # 5
    [3, 6, 0, 19], # 6
    [3, 7, 0, 15], # 7
    [3, 8, 0, 18], # 8
    [3, 9, 0, 4, 1, 8, 1, 5], # 9
    [3, 10, 1, 6], # 10
    [3, 11, 0, 6, 1, 7], # 11
    [3, 12, 1, 6, 0, 5], # 12
    [3, 13, 5, 24, 6, 0], # 13
    [3, 14, 1, 6, 8, 25, 0, 21], # 14
    [3, 15, 1, 6], # 15
    [3, 16, 1, 15, 0, 8, 1, 13], # 16
    [3, 17, 0, 8, 1, 14], # 17
    [3, 18, 2, 0], # 18
    [3, 19, 1, 12, 0, 10, 1, 10], # 19
    [3, 20, 0, 10, 1, 11], # 20
    [3, 21, 2, 0], # 21
    [3, 22, 1, 27, 0, 12, 1, 25, 1, 24], # 22
    [3, 23, 0, 12, 1, 26], # 23
    [3, 24, 2, 0], # 24
    [3, 25, 1, 17], # 25
    [3, 26, 1, 17, 1, 18], # 26
    [3, 27, 0, 16, 0, 13, 1, 16], # 27
    [3, 28, 1, 19, 0, 1, 0, 14], # 28
    [3, 29, 4, 26, 6, 0], # 29
    [3, 30, 8, 27, 1, 20, 1, 21], # 30
    [3, 31, 8, 28, 1, 20], # 31
    [3, 32, 1, 23, 0, 16, 1, 22], # 32
    [3, 33, 0, 20, 1, 1], # 33
    [3, 34, 0, 20, 1, 1], # 34
    [3, 35, 2, 0], # 35
    [3, 36, 1, 3, 0, 22, 1, 3], # 36
    [3, 37, 1, 2, 0, 22, 1, 2], # 37
    [3, 38, 0, 22, 1, 4], # 38
    [3, 39, 2, 0], # 39
    [3, 40, 0, 2], # 40
    [3, 41, 1, 9], # 41
    [3, 42, 0, 21], # 42
    [3, 43, 0, 17], # 43
    [3, 44, 0, 21], # 44
    [3, 45, 0, 21], # 45
  ].freeze

  CONFIG.table = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], # 0
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # 1
    [-1, 6, -1, -1, -1, 2, -1, -1, -1, -1, 4, -1, -1, 3, -1, -1, 7, -1, -1, -1, -1, -1, 8, -1, 5, -1, -1, -1], # 2
    [-1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 3
    [12, 12, 12, 12, 12, 12, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12], # 4
    [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13], # 5
    [-1, -1, 14, 14, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 6
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 7
    [18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18], # 8
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 9
    [21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21], # 10
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1], # 11
    [24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 23, 24], # 12
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 13
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 14
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 15
    [29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29], # 16
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, 30, -1, -1, -1, -1, -1, -1], # 17
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1, -1, -1], # 18
    [-1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 19
    [35, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35], # 20
    [-1, -1, 37, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 21
    [39, 39, 39, 39, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39], # 22
    [-1, 40, -1, -1, -1, 40, -1, -1, -1, -1, 40, -1, -1, 40, -1, -1, 40, -1, -1, -1, -1, -1, 40, -1, 40, -1, -1, -1], # 23
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, 41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 24
    [-1, -1, 42, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 25
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, 43, -1, -1, -1, -1, -1, -1], # 26
    [-1, -1, 44, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 27
    [-1, -1, 45, 45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 28
  ].freeze

  CONFIG.actions = [
    [:_rule_0, 1], # 0
    [:_rule_1, 1], # 1
    [:_rule_2, 1], # 2
    [:_rule_3, 1], # 3
    [:_rule_4, 1], # 4
    [:_rule_5, 1], # 5
    [:_rule_6, 1], # 6
    [:_rule_7, 1], # 7
    [:_rule_8, 1], # 8
    [:_rule_9, 3], # 9
    [:_rule_10, 1], # 10
    [:_rule_11, 2], # 11
    [:_rule_12, 2], # 12
    [:_rule_13, 1], # 13
    [:_rule_14, 3], # 14
    [:_rule_15, 1], # 15
    [:_rule_16, 3], # 16
    [:_rule_17, 2], # 17
    [:_rule_18, 0], # 18
    [:_rule_19, 3], # 19
    [:_rule_20, 2], # 20
    [:_rule_21, 0], # 21
    [:_rule_22, 4], # 22
    [:_rule_23, 2], # 23
    [:_rule_24, 0], # 24
    [:_rule_25, 1], # 25
    [:_rule_26, 2], # 26
    [:_rule_27, 3], # 27
    [:_rule_28, 3], # 28
    [:_rule_29, 1], # 29
    [:_rule_30, 3], # 30
    [:_rule_31, 2], # 31
    [:_rule_32, 3], # 32
    [:_rule_33, 2], # 33
    [:_rule_34, 2], # 34
    [:_rule_35, 0], # 35
    [:_rule_36, 3], # 36
    [:_rule_37, 3], # 37
    [:_rule_38, 2], # 38
    [:_rule_39, 0], # 39
    [:_rule_40, 1], # 40
    [:_rule_41, 1], # 41
    [:_rule_42, 1], # 42
    [:_rule_43, 1], # 43
    [:_rule_44, 1], # 44
    [:_rule_45, 1], # 45
  ].freeze

  ##
  # Hash mapping token types and dedicated error labels.
  #
  # @return [Hash]
  #
  TOKEN_ERROR_MAPPING = {
    :T_STRING         => 'string',
    :T_TEXT           => 'text',
    :T_DOCTYPE_START  => 'doctype start',
    :T_DOCTYPE_END    => 'doctype closing tag',
    :T_DOCTYPE_TYPE   => 'doctype type',
    :T_DOCTYPE_NAME   => 'doctype name',
    :T_DOCTYPE_INLINE => 'inline doctype rules',
    :T_CDATA          => 'CDATA',
    :T_COMMENT        => 'comment',
    :T_ELEM_START     => 'element start',
    :T_ELEM_NAME      => 'element name',
    :T_ELEM_NS        => 'element namespace',
    :T_ELEM_END       => 'element closing tag',
    :T_ATTR           => 'attribute',
    :T_ATTR_NS        => 'attribute namespace',
    :T_XML_DECL_START => 'XML declaration start',
    :T_XML_DECL_END   => 'XML declaration end',
    :T_PROC_INS_START => 'processing-instruction start',
    :T_PROC_INS_NAME  => 'processing-instruction name',
    :T_PROC_INS_END   => 'processing-instruction closing tag',
    -1                => 'end of input'
  }

  ##
  # @param [String|IO] data The input to parse.
  # @param [Hash] options
  # @see [Oga::XML::Lexer#initialize]
  #
  def initialize(data, options = {})
    @data  = data
    @lexer = Lexer.new(data, options)

    reset
  end

  ##
  # Resets the internal state of the parser.
  #
  def reset
    @line = 1

    @lexer.reset
  end

  ##
  # Yields the next token from the lexer.
  #
  # @yieldparam [Array]
  #
  def each_token
    @lexer.advance do |type, value, line|
      @line = line if line

      yield [type, value]
    end

    yield [-1, -1]
  end

  ##
  # @param [Fixnum] stack_type
  # @param [Fixnum] stack_value
  # @param [Symbol] token_type
  # @param [String] token_value
  #
  def parser_error(stack_type, stack_value, token_type, token_value)
    case id_to_type(stack_type)
    when :rule
      message = "Unexpected #{token_type} for rule #{stack_value}"
    when :terminal
      expected = id_to_terminal(stack_value)
      expected = TOKEN_ERROR_MAPPING[expected]   || expected
      got      = TOKEN_ERROR_MAPPING[token_type] || token_type
      message  = "Unexpected #{got}, expected #{expected} instead"
    when :eof
      message = 'Unexpected end of input'
    end

    message += " on line #{@line}"

    raise LL::ParserError, message
  end

  ##
  # @see [LL::Driver#parse]
  #
  def parse
    retval = super

    reset

    return retval
  end

  ##
  # @param [Array] children
  # @return [Oga::XML::Document]
  #
  def on_document(children = [])
    document = Document.new(:type => @lexer.html ? :html : :xml)

    children.each do |child|
      if child.is_a?(Doctype)
        document.doctype = child

      elsif child.is_a?(XmlDeclaration)
        document.xml_declaration = child

      else
        document.children << child
      end
    end

    return document
  end

  ##
  # @param [Hash] options
  #
  def on_doctype(options = {})
    return Doctype.new(options)
  end

  ##
  # @param [String] text
  # @return [Oga::XML::Cdata]
  #
  def on_cdata(text = nil)
    return Cdata.new(:text => text)
  end

  ##
  # @param [String] text
  # @return [Oga::XML::Comment]
  #
  def on_comment(text = nil)
    return Comment.new(:text => text)
  end

  ##
  # @param [String] name
  # @param [String] text
  # @return [Oga::XML::ProcessingInstruction]
  #
  def on_proc_ins(name, text = nil)
    return ProcessingInstruction.new(:name => name, :text => text)
  end

  ##
  # @param [Array] attributes
  # @return [Oga::XML::XmlDeclaration]
  #
  def on_xml_decl(attributes = [])
    options = {}

    attributes.each do |attr|
      options[attr.name.to_sym] = attr.value
    end

    return XmlDeclaration.new(options)
  end

  ##
  # @param [String] text
  # @return [Oga::XML::Text]
  #
  def on_text(text)
    return Text.new(:text => text)
  end

  ##
  # @param [String] namespace
  # @param [String] name
  # @param [Hash] attributes
  # @return [Oga::XML::Element]
  #
  def on_element(namespace, name, attributes = {})
    element = Element.new(
      :namespace_name => namespace,
      :name           => name,
      :attributes     => attributes
    )

    return element
  end

  ##
  # @param [Oga::XML::Element] element
  # @param [Array] children
  # @return [Oga::XML::Element]
  #
  def on_element_children(element, children = [])
    element.children = children

    return element
  end

  ##
  # @param [Oga::XML::Element] element
  # @return [Oga::XML::Element]
  #
  def after_element(element)
    return element
  end

  ##
  # @param [String] name
  # @param [String] ns_name
  # @param [String] value
  # @return [Oga::XML::Attribute]
  #
  def on_attribute(name, ns_name = nil, value = nil)
    return Attribute.new(
      :namespace_name => ns_name,
      :name           => name,
      :value          => value
    )
  end

  ##
  # @param [Array] attrs
  #
  def on_attributes(attrs)
    return attrs
  end

  def _rule_0(val)
     on_document(val[0]) 
  end

  def _rule_1(val)
    val[0]
  end

  def _rule_2(val)
    val[0]
  end

  def _rule_3(val)
    val[0]
  end

  def _rule_4(val)
    val[0]
  end

  def _rule_5(val)
    val[0]
  end

  def _rule_6(val)
    val[0]
  end

  def _rule_7(val)
    val[0]
  end

  def _rule_8(val)
    val[0]
  end

  def _rule_9(val)
    
      name   = val[1]
      follow = val[2]

      on_doctype(
        :name         => name,
        :type         => follow[0],
        :public_id    => follow[1],
        :system_id    => follow[2],
        :inline_rules => follow[3]
      )
    
  end

  def _rule_10(val)
     [] 
  end

  def _rule_11(val)
     [val[0], *val[1]] 
  end

  def _rule_12(val)
     [nil, nil, nil, val[0]] 
  end

  def _rule_13(val)
     val[0].inject(:+) 
  end

  def _rule_14(val)
     [val[0], val[1]] 
  end

  def _rule_15(val)
     nil 
  end

  def _rule_16(val)
     on_cdata(val[1]) 
  end

  def _rule_17(val)
     val[0] + val[1] 
  end

  def _rule_18(val)
     '' 
  end

  def _rule_19(val)
     on_comment(val[1]) 
  end

  def _rule_20(val)
     val[0] + val[1] 
  end

  def _rule_21(val)
     '' 
  end

  def _rule_22(val)
    
      on_proc_ins(val[1], val[2])
    
  end

  def _rule_23(val)
     val[0] + val[1] 
  end

  def _rule_24(val)
     '' 
  end

  def _rule_25(val)
     [nil, val[0]] 
  end

  def _rule_26(val)
     val 
  end

  def _rule_27(val)
    
      on_element(val[1][0], val[1][1], val[2])
    
  end

  def _rule_28(val)
    
      if val[0]
        on_element_children(val[0], val[1])
      end

      after_element(val[0])
    
  end

  def _rule_29(val)
     on_attributes(val[0]) 
  end

  def _rule_30(val)
     on_attribute(val[1], val[0], val[2]) 
  end

  def _rule_31(val)
     on_attribute(val[0], nil, val[1]) 
  end

  def _rule_32(val)
     on_xml_decl(val[1]) 
  end

  def _rule_33(val)
    
      text = val[1] ? val[0] + val[1] : val[0]

      on_text(text)
    
  end

  def _rule_34(val)
     val[1] ? val[0] + val[1] : val[0] 
  end

  def _rule_35(val)
     nil 
  end

  def _rule_36(val)
     val[1] 
  end

  def _rule_37(val)
     val[1] 
  end

  def _rule_38(val)
     val[0] + val[1] 
  end

  def _rule_39(val)
     '' 
  end

  def _rule_40(val)
    val[0]
  end

  def _rule_41(val)
    val[0]
  end

  def _rule_42(val)
    val[0]
  end

  def _rule_43(val)
    val[0]
  end

  def _rule_44(val)
    val[0]
  end

  def _rule_45(val)
    val[0]
  end
end
end
end
